# 컴파일

## 컴파일의 정의

컴파일은 인간이 이해할 수 있는 언어로 작성된 소스 코드(C, C++, Java 등)를 CPU가 이해할 수 있는 언어(기계어)로 번역(변환)하는 작업을 말한다. <br>
컴퓨터는 0,1로 이루어진 기계어만 이해할 수 있기 때문이다.<br>
소스 코드는 컴파일을 통해 기계어로 이루어진 실행파일이 된다. 이 파일을 실행하면 실행 파일 내용이 운영체제의 Loader를 통해 메모리에 적재되어 프로그램이 동작한다.

## 컴파일 과정

컴파일 과정은 4가지 단계(전처리 과정 - 컴파일 과정 - 어셈블리 과정 - 링킹 과정)로 이루어 진다.<br>
이 4가지 단계를 묶어서 컴파일 과정, 빌드 과정이라고 부르기도 하고, 컴파일 과정과 링킹 과정을 나눠서 부르기도 한다. <br>
보통 빌드 과정은 컴파일 과정보다 넓은 의미(빌드 = 컴파일 + 링킹)로 사용되는데, 상황에 맞게 이해하면 된다.

### 1. 전처리(Pre-processing) 과정

전처리기(Preprocessor)를 통해 소스 코드 파일(_.c)을 전처리된 소스 코드파일(_.i)로 변환하는 과정이다.<br>
이 과정에서 대표적으로 세 가지 작업을 수행한다.<br>

1. 주석 제거 : 소스 코드에서 주석을 전부 제거한다.
2. 헤더 파일 삽입 : #include 지시문을 만나면 해당하는 헤더 파일을 찾아 헤더 파일에 있는 모든 내용을 복사해서 소스 코드에 삽입한다. 즉, 헤더 파일은 컴파일에 사용되지 않고 소스 코드 파일 내에 전부 복사된다. 헤더 파일에 선언된 함수 원형은 후에 링킹 과정을 통해 실제로 함수가 정의되어 있는 오브젝트 파일(컴파일된 소스코드 파일)과 결합한다.
3. 매크로 치환 및 적용 : #define 지시문에 정의된 매크로를 저장하고 같은 문자열을 만나면 #define된 내용으로 치환한다. 간단하게 말해서 매크로 이름을 찾아서 미리 정의한 값으로 전부 바꿔준다.

### 2. 컴파일(Compilation) 과정

컴파일러(Compiler)를 통해 전처리된 소스 코드 파일(_.i)을 어셈블리어 파일(_.s)로 변환하는 과정이다.<br>
이 과정에서 일반적으로 컴파일 하면 생각나는 언어의 문법 검사가 이루어 진다. 또한 Static한 영역(Data, BSS영역)들의 메모리 할당을 수행한다.

#### 컴파일러 구조

컴파일러는 세 단계(프론트엔드 - 미들엔드 - 백엔드)로 구성되어 있다.

#### 프론트엔드

언어 종속적인 부분을 처리한다.
소스 코드가 해당 언어로 올바르게 작성되었는지 확인(어휘/구문/의미 분석)하고 미들엔드에 넘겨주기 위한 GIMPLE트리(소스 코드를 트리 형태로 표현한 자료 구조)를 생성한다.<br>
이 과정에서 C, C++, Java와 같은 다양한 언어들이 각 언어에 맞게 처리된 후 공통된 중간 표현(IR: Intermediate representation)인 GIMPLE 트리로 변환되므로 언어 종속적인 부분을 처리할 수 있다.

#### 미들엔드

아키텍처 비 종속적인 최적화를 수행한다.<br>
아키텍처 비 종속적인 최적화란 CPU 아키텍처가 무엇이든(arm, x86 등) 상관없이 할 수 있는 최적화를 말한다.<br>
프론트엔드에서 넘겨받은 GIMPLE 트리를 이용해서 아키텍처 비종속적인 최적화를 수행한 후 백엔드에서 사용하는 RTL(Register Transfer Language: 고급 언어와 어셈블리언어의 중간 형태)를 생성한다.

#### 백엔드

아키텍처 종속적인 최적화를 수행한다.
아키텍처 종속적인 최적화란 아키텍처 특성에 따라 최적화를 수행하는 것을 말한다. 같은 기능을 수행하는 명령어여도 CPU 아키텍처별로 더욱 효율적인 명령어로 대체하여 성능을 높이는 작업을 예로 들 수 있다.
<br>
미들엔드에서 넘겨받은 RTL을 이용해 아키텍처 종속적인 최적화를 수행하고 최적화가 완료되면 어셈블리 코드를 생성한다.<br>
아키텍처 종속적인 최적화를 수행하면 해당 아키텍처만 이해할 수 있는 언어가 되기 때문에 아키텍처가 맞지 않으면 어셈블리 코드를 해석할 수 없다.

#### 어셈블리어 정의

기계어는 다른말로 명령어(Machine Instruction)라고 부르는데, 명령어는 01010101과 같은 이진수로 이루어진 숫자이고, CPU 종류마다 고유한 내용을 가지고 있다.<br>
어셈블리어는 이런 명령어를 사람이 이해할 수 있게 부호화한 것으로 CPU명령어(기계어)와 1대1로 매칭된다.<br>
많은 컴파일러가 앞서 설명한 세 단계의 구조를 따르고 있지만, 컴파일러마다 차이가 존재한다.<br>
GNU에서 만든 C 컴파일러인 gcc는 프론트엔드/미들엔드/백엔드 단계가 깔끔하게 분리되어 있지 않고, 의존성이 존재한다. 하지만 오픈 소스 C 컴파일러인 Clang(프론트엔드) + LLVM(미들엔드, 백엔드)는 단계가 잘 분리되어 있다.
