# 동시성 vs 병렬성

![image](https://user-images.githubusercontent.com/89785501/187499277-c97aa79c-881c-4220-a526-45aee055cb59.png)

![image](https://user-images.githubusercontent.com/89785501/187499308-ac1adbc6-8f77-4a53-bfed-d67b2c6ff917.png)

| 동시성                                      | 병렬성                                      |
| ------------------------------------------- | ------------------------------------------- |
| 동시에 실행되는 것 같이 보이는 것           | 실제로 동시에 여러 작업이 처리되는 것       |
| 싱글 코어에서 멀티 스레드를 동작시키는 방식 | 멀티 코어에서 멀티 스레드를 동작시키는 방식 |
| 한 번에 많은 것을 처리                      | 한 번에 많은 일을 처리                      |
| 논리적인 개념                               | 물리적인 개념                               |

<br>

- 동시성은 여러 계산이 동시에 실행되는 컴퓨팅의 한 형태이다. (concurrently)
- 병렬성은 많은 계산 또는 프로세스 실행이 동시에 수행되는 계산 유형이다. (parallel, simultaneously)
- 
![image](https://user-images.githubusercontent.com/89785501/187505456-70c44196-1abb-49e6-baee-58156076efbb.png)

- Case 1은 concurrently하게 진행되며, simultaneously하게 진행되지 않는다.
- Case 2sms concurrently하고 simultaneously하게 진행된다.
- concurrently: 2개 이상의 ask (=코드, 알고리즘 등)를 수행할 때, 각 task는 다른 task의 수행 시점에 상관없이 수행이 가능하다는 의미이다. (sequencial의 반의어이다.) 즉, N개의 task의 실행 시간이 타임라인 상에서 겹칠 수 있다.
- simultaneously: 일반적으로 사용하는 '동시에' 라는 단어의 맥락과 일치한다.
- Case1은 먼저 시작된 task가 끝나지 않아도 다른 task를 시작할 수 있다. 즉, 동시성은 만족한다. 하지만 적절하게 시간을 나눠 자원을 interleaving 있으므로 물리적으로 정확하게 같은 시간대에 동시에 수행되는 것은 아니다. 따라서 병렬성은 만족하지 않는다.
- Case2는 먼저 시작된 task가 끝나지 않아도 또 다른 task를 시작할 수 있다. 즉, 동시성을 만족한다. 또한 같은 시간대에 각 task가 동시에 수행되므로 병렬성을 만족한다.

## 결론

- 병렬성을 만족하면, 동시성도 만족한다.
- 동시성을 만족한다고 해서 병렬성도 만족하는 것은 아니다.

## 예시

### 동시성

싱글 코어에서는 2개의 작업을 동시에 실행하는 것 처럼 보이기 위해 스레드가 번갈아 가면서 작업을 수행한다. 이 때, 다른 작업으로 바꾸어 실행할 때 내부적으로 Context Switch가 일어난다.<br>
멀티스레드로 동시성을 만족시킬 수 있는 것이지 동시성과 멀티스레드는 연관이 없다. 반례로 코틀린은 싱글스레드에서 코루틴을 이용하여 동시성을 만족시킬 수 있다.

### 병렬성

멀티 코어에서 멀티 스레드를 동작시키는 방식으로, 한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질을 말한다. 병렬성의 핵심은 물리적인 시간에 동시에 수행되는 것이지 멀티 코어에 포커스를 맞추면 안된다. 그 예로 네트워크 상의 여러 컴퓨터에 분산 작업을 요청하는 분산 컴퓨팅이 있다.
<br><br>

![image](https://user-images.githubusercontent.com/89785501/187499381-48189a26-0b66-4756-ba03-d7b5dd05af4a.png)

그림의 위쪽을 보면 하나의 커피머신에서 커피를 받기 위한 사람들이 줄을 서고 있다.<br> 서로 번갈아 가면서 커피를 받고, 이것을 동시성 처리라고 정의한다.<br> 반면 그림의 아래쪽은 2개의 커피머신이 있고 각 커피머신마다 하나의 줄을 가지고 있어서 각각의 줄에 커피를 공급할 수 있다.<br> 이것을 병렬처리라고 한다.<br>

- 병렬성이 멀티 코어 + 멀티 스레드 작업이라서 항상 더 좋을것같지만, 동시성으로 접근하는게 좋은 경우도 있다.
  예) 네트워크 통신, 파일 저장 및 로드 등의 I/O 작업은 CPU가 거의 일을 하지 않고 요청 후 응답이 올ㄷ 때 까지 대기 상태에 있게 된다. 이 때 한 개의 CPU가 I/O 요청 후 기다리는 동안 다른 작업을 처리하도록 하면 효율적이다.
- 병렬작업으로 여러 CPU가 동시에 다수 I/O 작업을 실행하게 할 수 있지만, 물리적인 CPU의 경우 개수 제한이 있기 때문에 동시성으로 접근하는 것이 좋다.
- 동시성과 병렬성을 혼용해서 처리하는 경우도 있다.
- 동시성은 작업이 바뀔 때 Context Switching이 발생하고, 동시 작업이 너무 많다면 Context Switching의 오버헤드로 인해 싱글코어에서 싱글 스레드로 작업하는 것이 더 빠를 수도 있다.
- 코어가 N배로 늘어나더라도 성능이 N배로 늘어나는 것은 아니다. (암달의 법칙): 프로그램의 모든 부분을 병렬적으로 작성할 수 없고 반드시 동시적으로 동작해야 하는 부분들이 존재한다.

### 예제 케이스

- 싱글 코어, 1개의 쓰레드에서 순차적으로 2개의 task 진행 - 동시성과 병렬성 모두 만족하지 못한다. seqeuncial 한 작업. 총 수행시간은 2
- 싱글 코어, 1개의 쓰레드에서 2개의 task 가 자원을 interleaving 하며 진행 - 동시성을 만족하지만 병렬성을 만족하지 못한다. 총 수행 시간은 2 + @ (있을수도 없을 수도 있다. interleaving 코스트)
- 싱글 코어, 2개의 쓰레드에서 2개의 task 가 자원을 interleaving 하며 진행 - 동시성을 만족하지만 병렬성은 만족하지 못함. 총 수행 시간은 2보다 작다.
- 멀티 코어, 2개의 쓰레드에서 2개의 task 가 동시에 진행 - 동시성, 병렬성을 모두 만족함. 총 수행 시간은 2보다 작다.
- (보너스) 코틀린 내에서 싱글 코어, 1개의 쓰레드내에서 2개의 코루틴을 통해 2개의 task 가 진행 - 동시성은 만족하지만 병렬성은 만족하지 못함. 총 수행 시간은 2보다 작으며, 2개의 쓰레드를 사용했을 때보다 코스트가 낮다.

#### 출처

- https://seamless.tistory.com/42
- https://mentha2.tistory.com/245
- https://vagabond95.me/posts/concurrency_vs_parallelism/
